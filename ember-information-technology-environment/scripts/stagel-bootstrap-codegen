#!/usr/bin/env bash
# shellcheck disable=SC1091
source ember_bash_setup &> /dev/null || { printf '%b' '\033[1;31m' >&2; echo "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd): The required dependency ember-shared could not be found (or ember_bash_setup could not be sourced for some other reason)." >&2; printf '%b' '\033[0m' >&2; exit 1; }
#set -x

trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR

# Takes parsed StageL tokens from standard input, and prints out equivalent code in the language of the first argument (bash/js).

debugBuild="--debug"
if [[ "$1" == "--debug" ]]; then
    debugBuild="--debug"
    shift
elif [[ "$1" == "--no-debug" ]]; then
    debugBuild="--no-debug"
    shift
fi
typecheckBuild="--runtime-type-checks"
if [[ "$1" == "--runtime-type-checks" ]]; then
    typecheckBuild="--runtime-type-checks"
    shift
elif [[ "$1" == "--no-runtime-type-checks" ]]; then
    typecheckBuild="--no-runtime-type-checks"
    shift
fi

targetLang="$1"

generateDebugCode() {
    if [[ "$debugBuild" == "--no-debug" ]]; then
        return 1
    fi
    return 0
}
generateRuntimeTypeCheckCode() {
    if [[ "$typecheckBuild" == "--no-runtime-type-checks" ]]; then
        return 1
    fi
    return 0
}

# Read token data into tokens array

tokens=()

while IFS=$'\n' read -r line; do
    tokens+=("$line")
done

tokenCount="${#tokens[@]}"

#declare -p tokens >&2
echo "Document contains $((tokenCount / 3)) tokens." >&2
for (( i=0; i<tokenCount; i++ )); do
    ! (( (i+1) % 3 )) && echo "Token #$((i / 3 + 1)) (${tokens[$i - 2]}): ${tokens[$i - 1]} ($((i-1))): ${tokens[$i]} ($i)" >&2
done

# We now know what each token is, so let's do the code generation.

if [[ "$targetLang" == "parsed" ]]; then
    # Just dump the parse results and exit; for correct input this should produce identical output.
    for (( i=0; i<tokenCount; i++ )); do
        echo "${tokens[$i]}"
    done
    true
    exit
fi

# Rewrite loop shorthand
tokensWereRewritten=""
tokensTemp=()
tokensLoopFound=""
tokensDoneLoopRewrites=""
loopSrcPos=""
loopSrcType=""
loopSrcId=""
loopOperPos=""
loopIdxPos=""
loopIdxType=""
loopIdxId=""
loopElemPos=""
loopElemType=""
loopElemId=""
loopNewlinePos=""
loopIndentPos=""
loopIndentLevel=""
loopElemPosIndented=""
loopIdxPosIndented=""
while [[ "$tokensDoneLoopRewrites" != "true" ]]; do
    if [[ "$tokensLoopFound" == "true" ]]; then
        tokens=("${tokensTemp[@]}")
        tokensWereRewritten="true"
        tokensTemp=()
        tokensLoopFound="false"
    fi
    if ! contains "loop-block" "${tokens[@]}"; then
        tokensDoneLoopRewrites="true"
    fi
    if [[ "$tokensDoneLoopRewrites" != "true" ]]; then
        if [[ "$tokensLoopFound" != "true" ]]; then
            for (( i=0; i<tokenCount; i++ )); do
                if ! (( (i+1) % 3 )); then
                    if [[ "${tokens[$i-1]}" == "loop-block" ]]; then
                        tokensTemp=("${tokens[@]:0:$i-5}") # does not include tokens[$i-5]
                        loopSrcPos="${tokens[$i-5]}"
                        loopSrcType="${tokens[$i-4]}"
                        loopSrcId="${tokens[$i-3]}"
                        loopOperPos="${tokens[$i-2]}"
                        loopIdxPos="${tokens[$i+1]}"
                        loopIdxType="${tokens[$i+2]}"
                        [[ "$loopIdxType" == "ident-n" ]] || die "Loop index identifier must be an integer."
                        loopIdxId="${tokens[$i+3]}"
                        loopElemPos="${tokens[$i+4]}"
                        loopElemType="${tokens[$i+5]}"
                        loopElemId="${tokens[$i+6]}"
                        loopNewlinePos="${tokens[$i+7]}"
                        loopIndentPos="${tokens[$i+10]}"
                        loopIndentLevel="${loopIndentPos##*:}"
                        loopIndentLevel=$((loopIndentLevel+1))
                        loopElemPosIndented="${loopElemPos%:*}:$loopIndentLevel"
                        loopIdxPosIndented="${loopIdxPos%:*}:$loopIndentLevel"
                        tokensTemp+=( "$loopOperPos" "command" "new" )
                        tokensTemp+=( "$loopIdxPos" "ident-n" "$loopIdxId" )
                        tokensTemp+=( "$loopOperPos" "newline" "" )
                        tokensTemp+=( "$loopOperPos" "command" "new" )
                        tokensTemp+=( "$loopElemPos" "$loopElemType" "$loopElemId" )
                        tokensTemp+=( "$loopOperPos" "newline" "" )
                        tokensTemp+=( "$loopOperPos" "command" "while" )
                        tokensTemp+=( "$loopOperPos" "command" "lt" )
                        tokensTemp+=( "$loopOperPos" "ident-n" "$loopIdxId" )
                        tokensTemp+=( "$loopOperPos" "command" "count" )
                        tokensTemp+=( "$loopSrcPos" "$loopSrcType" "$loopSrcId" )
                        tokensTemp+=( "$loopNewlinePos" "newline" "" )
                        tokensTemp+=( "$loopIndentPos" "indent" "" )
                        tokensTemp+=( "$loopElemPosIndented" "command" "set" )
                        tokensTemp+=( "$loopElemPosIndented" "$loopElemType" "$loopElemId" )
                        tokensTemp+=( "$loopElemPosIndented" "command" "get" )
                        tokensTemp+=( "$loopElemPosIndented" "$loopSrcType" "$loopSrcId" )
                        tokensTemp+=( "$loopElemPosIndented" "ident-n" "$loopIdxId" )
                        tokensTemp+=( "$loopElemPosIndented" "newline" "" )
                        tokensTemp+=( "$loopIdxPosIndented" "command" "set" )
                        tokensTemp+=( "$loopIdxPosIndented" "ident-n" "$loopIdxId" )
                        tokensTemp+=( "$loopIdxPosIndented" "command" "inc" )
                        tokensTemp+=( "$loopIdxPosIndented" "ident-n" "$loopIdxId" )
                        tokensTemp+=( "$loopIdxPosIndented" "newline" "" )
                        tokensTemp+=("${tokens[@]:$i+13}")
                        tokensLoopFound="true"
                    fi
                fi
            done
        fi
    fi
done
if [[ "$tokensWereRewritten" == "true" ]]; then
    tokenCount="${#tokens[@]}"
    echo "Prepared document contains $((tokenCount / 3)) tokens." >&2
    for (( i=0; i<tokenCount; i++ )); do
        ! (( (i+1) % 3 )) && echo "Token #$((i / 3 + 1)) (${tokens[$i - 2]}): ${tokens[$i - 1]} ($((i-1))): ${tokens[$i]} ($i)" >&2
    done
fi

# Set up the variables we'll need for going through the tokens and generating the code

codegenIndent=0
codegenLastKnownArglistCount=0
codegenRoutineType=""
codegenRoutineName=""
codegenInvocationLevel="0" # Counts the indentation depth of $() command substitutions for Bash. Invocations that don't have $() around them are not counted in this variable for Bash.
codegenArgList=()
codegenNewLine="true"
codegenNewlineLookingForSpaces="true" # True while finding indentation spaces at the beginning of a line.
codegenTestIndentDeferred="false" # True while waiting to come to the code-block portion of a "test"-style construct (e.g. "if") that has a multiline test part
codegenArrayLiteral=""
stateStack=("root" "code")
blockStack=("root" "")
testParameterFound="false" # This is set to "false" usually. When a token that uses a "test" syntax (e.g. if, or any other thing that first takes a value and also starts a code block) is encountered, it stays false until something representing a value is found, at which point it is set to "true". It's returned to "false" once the test's associated code block is located.
codegenStatus="Nothing done yet"
tokenLookahead=""
filename=""

# Define a function for each type of output needed for code generation

codegenOnNewLine() {
    [[ "$codegenNewLine" == "true" ]]
}

codegenOutput() {
    echo "(codegenOutput: $*)" >&2
    print "${@}"
    if [[ "$*" == *$'\n' ]]; then
        codegenNewLine="true"
        codegenNewlineLookingForSpaces="true"
    elif [[ "$codegenNewlineLookingForSpaces" == "true" ]] && [[ "$*" == *$'    ' ]]; then
        codegenNewLine="true"
        codegenNewlineLookingForSpaces="true"
    else
        codegenNewLine="false"
    fi
}

codegenDebug() {
    echo "$codegenStatus (Debug info: Codegen: $1, routine $codegenRoutineType:$codegenRoutineName / Args: $* / States: ${stateStack[*]} / Blocks: ${blockStack[*]} / Arglist: ${codegenArgList[*]} / ($codegenNewlineLookingForSpaces/$codegenTestIndentDeferred/$testParameterFound).)" >&2
    #print_r "${blockStack[@]}" >&2
}

codegenFormatType() {
    codegenDebug "FormatType" "${@}" >&2
    # First arg: type; second arg: "true" for uppercase first letter; third arg "true" for don't die and return an empty string instead
    local result=""
    case "$targetLang" in
    bash|c|cpp|cs|java|js|p6|php|pl|sh)
        [[ "$1" == "literal-b" ]] && result='bool'
        [[ "$1" == "literal-n" ]] && result='int'
        [[ "$1" == "literal-s" ]] && result='str'
        [[ "$1" == "ident-b" ]] && result='bool'
        [[ "$1" == "ident-g" ]] && result='generic'
        [[ "$1" == "ident-n" ]] && result='int'
        [[ "$1" == "ident-s" ]] && result='str'
        [[ "$1" == "ident-ab" ]] && result='boolArray'
        [[ "$1" == "ident-an" ]] && result='intArray'
        [[ "$1" == "ident-as" ]] && result='strArray'
        [[ "$1" == "ident-ga" ]] && result='genericArray'
        [[ "$1" == "ident-gi" ]] && result='genericItem'
        [[ "$1" == "ident-r-b" ]] && result='bool'
        [[ "$1" == "ident-r-n" ]] && result='int'
        [[ "$1" == "ident-r-s" ]] && result='str'
        [[ "$1" == "ident-r-v" ]] && result='void'
        [[ "$1" == "ident-r-ab" ]] && result='boolArray'
        [[ "$1" == "ident-r-an" ]] && result='intArray'
        [[ "$1" == "ident-r-as" ]] && result='strArray'
        #[[ -z "$result" ]] && result="$1"
        [[ -z "$result" ]] && [[ "$3" != "true" ]] && die "$1 is not a recognized type!"
        if [[ "$2" == "true" ]]; then
            codegenOutput "${result^}"
        else
            codegenOutput "$result"
        fi
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenType() {
    codegenDebug "Type" "${@}" >&2
    local result=""
    case "$targetLang" in
    c)
        [[ "$1" == "literal-n" ]] && result='long'
        [[ "$1" == "literal-s" ]] && result='char[]'
        [[ "$1" == "ident-g" ]] && result='generic'
        [[ "$1" == "ident-n" ]] && result='long'
        [[ "$1" == "ident-s" ]] && result='char[]'
        [[ "$1" == "ident-ab" ]] && result='bool[]'
        [[ "$1" == "ident-an" ]] && result='long[]'
        [[ "$1" == "ident-as" ]] && result='char[][]' # FIXME https://github.com/antirez/sds
        [[ "$1" == "ident-ga" ]] && result='genericArray'
        [[ "$1" == "ident-gi" ]] && result='genericItem'
        [[ "$1" == "ident-r-b" ]] && result='bool'
        [[ "$1" == "ident-r-n" ]] && result='long'
        [[ "$1" == "ident-r-s" ]] && result='char[]'
        [[ "$1" == "ident-r-v" ]] && result='void'
        [[ "$1" == "ident-r-ab" ]] && result='bool[]'
        [[ "$1" == "ident-r-an" ]] && result='long[]'
        [[ "$1" == "ident-r-as" ]] && result='char[][]'
        [[ -z "$result" ]] && result="$(codegenFormatType "$1" "" "true")"
        [[ -z "$result" ]] && die "$1 is not a recognized type!"
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

# shellcheck disable=SC2120
codegenStringLiteralDelim() {
    codegenDebug "LiteralDelim" "${@}" >&2
    case "$targetLang" in
    js|bash|sh)
        codegenOutput \'
        ;;
    c|cpp)
        codegenOutput \"
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenLiteral() {
    codegenDebug "Literal" "${@}" >&2
    # First arg: type; second arg: value
    case "$targetLang" in
    bash|c|cpp|cs|java|js|p6|php|pl|sh)
        case "$1" in
        "literal-s")
            tempSubstitution="$(asciiDecListToText "$2")"
            codegenStringLiteralDelim
            codegenOutput "${tempSubstitution//\\/\\\\}"
            codegenStringLiteralDelim
            ;;
        "literal-n"|"literal-b")
            codegenOutput "$2"
            ;;
        literal-a*)
            codegenOutput "$2"
            ;;
        esac
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenReference() {
    codegenDebug "Reference" "${@}" >&2
    # Reference to a variable
    # First arg: type; second arg: name
    case "$targetLang" in
    c|cpp|cs|java|js|p6|php|pl)
        codegenFormatType "$1"
        codegenOutput "${2^}"
        ;;
    bash|sh)
        codegenOutput '"$'
        codegenFormatType "$1"
        codegenOutput "${2^}"'"'
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenPrintIndentationSpaces() {
    for (( j=0; j<codegenIndent; j++ )); do
        if [[ "$1" == "--force" ]] || codegenOnNewLine; then
            codegenOutput '    '
        fi
    done
    true
}

# shellcheck disable=SC2120
codegenStartDocument() {
    codegenDebug "Start document" "${@}" >&2
    case "$targetLang" in
    bash|c|cpp|cs|java|js|p6|php|pl|sh)
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

# shellcheck disable=SC2120
codegenEndDocument() {
    codegenDebug "End document" "${@}" >&2
    case "$targetLang" in
    bash|c|cpp|cs|java|js|p6|php|pl|sh)
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

# shellcheck disable=SC2120
codegenIndent() {
    codegenDebug "Indent" "${@}" >&2
    codegenOnNewLine && codegenPrintIndentationSpaces
    case "$targetLang" in
    c|cpp|cs|java|js|p6|php|pl)
        codegenOnNewLine || codegenOutput ' '
        codegenOutput '{'$'\n'
        ;;
    bash|sh)
        codegenOutput $'\n'
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

# shellcheck disable=SC2120
codegenDedent() {
    codegenDebug "Dedent" "${@}" >&2
    #codegenIndent=$(( codegenIndent - 1 ))
    codegenPrintIndentationSpaces
    #codegenIndent=$(( codegenIndent + 1 ))
    case "$targetLang" in
    c|cpp|cs|java|js|p6|php|pl)
        codegenOutput '}'$'\n'
        ;;
    bash|sh)
        if [[ "${blockStack[-4]}" =~ ^test-body-if|test-body-elif$ ]]; then
            codegenOutput 'fi'$'\n'
        elif [[ "${blockStack[-4]}" =~ ^test-body-while|test-body-until$ ]]; then
            codegenOutput 'done'$'\n'
        else
            codegenOutput $'\n'
        fi
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
    #set +x
}

codegenComment() {
    codegenDebug "Comment" "${@}" >&2
    codegenPrintIndentationSpaces
    case "$targetLang" in
    c|cpp|cs|java|js|p6|php|pl)
        codegenOutput "/*""$1 */"$'\n'
        ;;
    bash|sh)
        codegenOutput "#""$1"$'\n'
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenArglistHasInvocation() {
    local counter="${#codegenArgList[@]}"
    while [[ "$counter" -ge 0 ]]; do
        if  [[ "${codegenArgList[$counter]}" == ident-r-* ]]; then
            return 0
        fi
        counter=$(( counter - 1 ))
    done
    return 1
}

codegenGetCurrentRoutineType() {
    local counter="${#blockStack[@]}"
    while [[ "$counter" -ge 0 ]]; do
        if ( codegenFormatType "${blockStack[$counter]}" &> /dev/null; ); then
            codegenOutput "${blockStack[$counter]}"
            return 0
        fi
        counter=$(( counter - 1 ))
    done
}

codegenInitializeType() {
    codegenDebug "Initialize type" "${@}" >&2
    case "$targetLang" in
    bash|c|cpp|cs|java|js|p6|php|pl|sh)
        codegenOutput " = "
        case "$1" in
        "bool")
            codegenOutput 'false'
            ;;
        "int")
            codegenOutput '0'
            ;;
        "str")
            codegenStringLiteralDelim
            codegenStringLiteralDelim
            ;;
        "boolArray")
            codegenOutput "[]"
            ;;
        "intArray")
            codegenOutput "[]"
            ;;
        "strArray")
            codegenOutput "[]"
            ;;
        "genericArray")
            codegenOutput "[]"
            ;;
        *)
            die "Initialize requested for unexpected type of $1."
        esac
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenStartArray() {
    codegenDebug "Start array" "${@}" >&2
    case "$targetLang" in
    bash|c|cpp|cs|java|js|p6|php|pl|sh)
        codegenOutput '[ '
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

# shellcheck disable=SC2120
codegenArrayEntryDelimiter() {
    codegenDebug "Start array" "${@}" >&2
    case "$targetLang" in
    bash|c|cpp|cs|java|js|p6|php|pl|sh)
        codegenOutput ', '
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenEndArray() {
    codegenDebug "End array" "${@}" >&2
    case "$targetLang" in
    bash|c|cpp|cs|java|js|p6|php|pl|sh)
        codegenOutput ' ]'
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

# shellcheck disable=SC2120
codegenCommandInvocationStart() {
    codegenDebug "Command invocation start" "${@}" >&2
    case "$codegenRoutineName" in
    new)
        if codegenArglistHasInvocation; then
            die "Sorry, invoking functions isn't available when declaring a variable. Please use set to assign it after declaration."
        fi
        codegenPrintIndentationSpaces
        case "$targetLang" in
        bash|c|cpp|cs|java|js|p6|php|pl|sh)
            if [[ "c" == "$targetLang" ]]; then
                codegenType "${codegenArgList[-2]}"
                codegenOutput ' '
            else
                codegenOutput "let "
            fi
            if [[ "${#codegenArgList[@]}" -ge 4 ]]; then
                codegenReference "${codegenArgList[-4]}" "${codegenArgList[-3]}"
                codegenOutput ' = '
                codegenLiteral "${codegenArgList[-2]}" "${codegenArgList[-1]}"
            else
                #set -x
                codegenReference "${codegenArgList[-2]}" "${codegenArgList[-1]}"
                if [[ "$tokenLookahead" =~ ^(ident-|literal-) ]]; then
                    codegenOutput ' = '
                    tokenLookahead=""
                else
                    local type
                    type="$(codegenFormatType "${codegenArgList[-2]}")"
                    [[ "$type" =~ ^(generic|genericItem)$ ]] || codegenInitializeType "$type"
                fi
                #set +x
            fi
            ;;
        *)
            die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
        esac
        ;;
    return)
        if codegenArglistHasInvocation; then
            die "Sorry, invoking functions isn't available when returning. Please assign the value to a variable and return that."
        fi
        codegenOutput $'\n'
        codegenPrintIndentationSpaces
        case "$targetLang" in
        js|bash)
            local returnType
            returnType="$(codegenGetCurrentRoutineType)" || true
            [[ -z "$returnType" ]] && die "Tried to return, but was not inside a routine!"
            case "$targetLang" in
            js)
                codegenFormatType "$returnType"
                codegenOutput "Return = "
                ;;
            bash)
                codegenFormatType "$returnType"
                codegenOutput "Return="
                ;;
            *)
                die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
            esac
            if [[ "${codegenArgList[-2]}" == ident-* ]]; then
                codegenReference "${codegenArgList[-2]}" "${codegenArgList[-1]}"
            else
                codegenLiteral "${codegenArgList[-2]}" "${codegenArgList[-1]}"
            fi
            if generateRuntimeTypeCheckCode; then
                case "$targetLang" in
                js)
                    codegenOutput "; await assertIs"
                    codegenFormatType "$returnType" true
                    codegenOutput "("
                    codegenFormatType "$returnType"
                    codegenOutput "Return); "
                    ;;
                bash)
                    codegenOutput "; assertIs"
                    codegenFormatType "$returnType" true
                    codegenOutput " "
                    codegenFormatArgument "$returnType" "Return"
                    codegenOutput "; "
                    ;;
                *)
                    die "${FUNCNAME[0]} is not implemented in $targetLang."
                ;;
                esac
            else
                codegenOutput "; "
            fi
            codegenRoutineDefinitionPreEnd
            case "$targetLang" in
            js)
                codegenOutput "return "
                codegenFormatType "$returnType"
                codegenOutput "Return;"$'\n'
                ;;
            bash)
                codegenOutput 'print '
                codegenFormatArgument "$returnType" "Return"
                codegenOutput $'\n'
                ;;
            *)
                die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
            esac
            ;;
        *)
            die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
        esac
        ;;
    if|while)
        codegenPrintIndentationSpaces
        case "$targetLang" in
        c|cpp|cs|java|js|p6|php|pl)
            codegenOutput "$codegenRoutineName ("
            ;;
        bash|sh)
            codegenOutput "$codegenRoutineName"' [[ "true" == '
            ;;
        *)
            die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
        esac
        ;;
    else|debugger)
        # debugger isn't a StageL command, but I want to be able to use it in firefox js
        codegenPrintIndentationSpaces
        codegenOutput "$codegenRoutineName"
        ;;
    elif)
        codegenPrintIndentationSpaces
        codegenOutput "else if ("
        ;;
    until)
        codegenPrintIndentationSpaces
        codegenOutput "while (!("
        # Pretend it's in an arglist to make it close the parenthesis for the outside of the while
        # This doesn't work. I guess it'll just be necessary to forgo split-line untils for now, although I'm not sure split-line commands are really desirable regardless. FIXME
        #stateStack+=("arglist")
        ;;
    and|not|eq|gt|lt|add|sub|mul|div|mod|cat|die|error|warn|log|debug|in)
        codegenPrintIndentationSpaces
        # These commands are implemented with impl* calls
        # The only purpose of using "impl" now is to prevent collisions with things that are likely to be reserved words in target languages; so, e.g. "implFIXMEUnimplemented" is unnecessary since it can just be "FIXMEUnimplemented" and be unlikely to collide.
        case "$targetLang" in
        js)
            codegenOutput "await impl${codegenRoutineName^}("
            ;;
        bash)
            if codegenOnNewLine; then
                codegenOutput "impl${codegenRoutineName^}"
            else
                #if [[ "0" != "$codegenInvocationLevel" ]]; then
                #    codegenOutput ' '
                #fi
                codegenOutput '"$('"impl${codegenRoutineName^} "
                codegenInvocationLevel=$(( codegenInvocationLevel + 1 ))
            fi
            ;;
        *)
            die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
        esac
        ;;
    set)
        codegenPrintIndentationSpaces
        if [[ "${#codegenArgList[@]}" -ge 4 ]]; then
            codegenReference "${codegenArgList[-4]}" "${codegenArgList[-3]}"
            case "$targetLang" in
            c|cpp|cs|java|js|p6|php|pl)
                codegenOutput ' = '
                codegenLiteral "${codegenArgList[-2]}" "${codegenArgList[-1]}"
                codegenOutput ";"$'\n'
                ;;
            bash|sh)
                codegenOutput '='
                codegenLiteral "${codegenArgList[-2]}" "${codegenArgList[-1]}"
                codegenOutput $'\n'
                ;;
            *)
                die "${FUNCNAME[0]} is not implemented in $targetLang."
                ;;
            esac
        else
            # It's getting set to a command's return value
            codegenReference "${codegenArgList[-2]}" "${codegenArgList[-1]}"
            case "$targetLang" in
            c|cpp|cs|java|js|p6|php|pl)
                codegenOutput ' = '
                ;;
            bash|sh)
                codegenOutput '='
                ;;
            *)
                die "${FUNCNAME[0]} is not implemented in $targetLang."
                ;;
            esac
            unset 'codegenArgList[-1]'
            unset 'codegenArgList[-1]'
        fi
        ;;
    *)
        codegenPrintIndentationSpaces
        case "$targetLang" in
        js)
            codegenOutput "await $codegenRoutineName("
            ;;
        c|cpp|cs|java|p6|php|pl)
            codegenOutput "$codegenRoutineName("
            ;;
        bash|sh)
            if codegenOnNewLine; then
                codegenOutput "$codegenRoutineName"
            else
                #if [[ "0" != "$codegenInvocationLevel" ]]; then
                #    codegenOutput ' '
                #fi
                codegenOutput '"$('"$codegenRoutineName "
                codegenInvocationLevel=$(( codegenInvocationLevel + 1 ))
            fi
            ;;
        *)
            die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
        esac
        ;;
    esac
    codegenRoutineType=""
    codegenRoutineName=""
    codegenArgList=()
}

# shellcheck disable=SC2120
codegenCommandInvocationArgSeparator() {
    codegenDebug "Command invocation argument separator" "${@}" >&2
    case "$targetLang" in
    c|cpp|cs|java|js|p6|php|pl)
        codegenOutput ", "
        ;;
    bash|sh)
        codegenOutput ' '
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

# shellcheck disable=SC2120
codegenCommandInvocationArglist() {
    codegenDebug "Command invocation argument list" "${@}" >&2
    case "$targetLang" in
    bash|c|cpp|cs|java|js|p6|php|pl|sh)
    #set -x
        argumentCount="${#codegenArgList[@]}"
        codegenLastKnownArglistCount="$argumentCount"
        for (( k=0; k<argumentCount; k++ )); do
            if (( k % 2 )); then
                if [[ "${codegenArgList[$k - 1]}" == literal-* ]]; then
                    codegenLiteral "${codegenArgList[$k - 1]}" "${codegenArgList[$k]}"
                else
                    codegenReference "${codegenArgList[$k - 1]}" "${codegenArgList[$k]}"
                fi
                if [[ "$k" != $((argumentCount - 1)) ]]; then
                    codegenCommandInvocationArgSeparator
                fi
            fi
        done
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
    codegenRoutineType=""
    codegenRoutineName=""
    codegenArgList=()
}

# shellcheck disable=SC2120
codegenCommandInvocationEnd() {
    codegenDebug "Command invocation end" "${@}" >&2
    case "$codegenRoutineName" in
    return|new)
        # This shouldn't happen, because it's all handled in codegenCommandInvocationStart
        die "Internal error (this is a bug): codegenCommandInvocationEnd called for return"
        ;;
    #add|eq|mod)
        # These commands are implemented with impl* calls
    #    case "$targetLang" in
    #    bash|c|cpp|cs|java|js|p6|php|pl|sh)
    #        codegenOutput ")"
    #        ;;
    #    *)
    #        die "${FUNCNAME[0]} is not implemented in $targetLang."
    #        ;;
    #    esac
    #    ;;
    *)
        #codegenPrintIndentationSpaces
        case "$targetLang" in
        c|cpp|cs|java|js|p6|php|pl)
            { [[ "${blockStack[-2]}" == "command" ]] && [[ "${blockStack[-1]}" =~ ^(new|return|set|else|debugger)$ ]]; } || codegenOutput ")"
            ;;
        bash|sh)
            if [[ "${blockStack[-1]}" =~ ^(if|elif|while|until)$ ]]; then
                codegenOutput ' ]]; then'
            elif [[ "0" != "$codegenInvocationLevel" ]]; then
                codegenOutput ')"'
                codegenInvocationLevel=$(( codegenInvocationLevel - 1 ))
            fi
            ;;
        *)
            die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
        esac
        ;;
    esac
    if ! contains "test" "${stateStack[@]}"; then
        [[ "${stateStack[-2]}" != "arglist" ]] && [[ "${blockStack[-1]}" != "else" ]] && codegenOutput ';'$'\n'
    fi
    blockStackRemoveLast
    codegenRoutineType=""
    codegenRoutineName=""
    codegenArgList=()
}

codegenFormatArgument() {
    codegenDebug "Format argument" "${@}" >&2
    codegenArgumentType="$1"
    codegenArgumentName="$2"
    case "$targetLang" in
    c|cpp|cs|java|js|p6|php|pl|sh)
        codegenFormatType "${codegenArgumentType}"
        codegenOutput "${codegenArgumentName^}"
        ;;
    bash)
        if [[ "$(codegenFormatType "${codegenArgumentType}")" =~ ^(boolArray|intArray|strArray|genericArray|genericItem)$ ]]; then
            # shellcheck disable=SC2016
            codegenOutput '"$(join_by $'\''\037'\'' "${'
            codegenFormatType "${codegenArgumentType}"
            codegenOutput "${codegenArgumentName^}"'[@]}")"'
        else
            codegenOutput '"$'
            codegenFormatType "${codegenArgumentType}"
            codegenOutput "${codegenArgumentName^}"'"'
        fi
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

# shellcheck disable=SC2120
codegenRoutineDefinitionStart() {
    codegenDebug "Routine definition start" "${@}" >&2
    case "$targetLang" in
    bash|c|cpp|cs|java|js|p6|php|pl|sh)
        case "$targetLang" in
        js)
            codegenOutput "async function $codegenRoutineName("
            argumentCount="${#codegenArgList[@]}"
            for (( k=0; k<argumentCount; k++ )); do
                if (( k % 2 )); then
                    codegenFormatType "${codegenArgList[$k - 1]}"
                    if [[ "$k" == $((argumentCount - 1)) ]]; then
                        codegenOutput "${codegenArgList[$k]^}"
                    else
                        codegenOutput "${codegenArgList[$k]^}, "
                    fi
                fi
            done
            codegenOutput ") {"$'\n'
            ;;
        bash)
            codegenOutput "$codegenRoutineName() {"
            ;;
        *)
            die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
        esac

        codegenIndent=$(( codegenIndent + 1 ))
        codegenPrintIndentationSpaces
        codegenIndent=$(( codegenIndent - 1 ))

        case "$targetLang" in
        js)
            true
            ;;
        bash)
            argumentCount="${#codegenArgList[@]}"
            for (( k=0; k<argumentCount; k++ )); do
                if (( k % 2 )); then
                    if [[ "$(codegenFormatType "${codegenArgList[$k - 1]}")" =~ ^(boolArray|intArray|strArray|genericArray|genericItem)$ ]]; then
                        codegenOutput 'IFS=$'\''\037'\'' read -r -a '\'
                        codegenFormatType "${codegenArgList[$k - 1]}"
                        if [[ "$k" == $((argumentCount - 1)) ]]; then
                            if generateDebugCode; then
                                # shellcheck disable=SC2016
                                codegenOutput "${codegenArgList[$k]^}"' <<< "$1"; shift; '
                            else
                                # shellcheck disable=SC2016
                                codegenOutput "${codegenArgList[$k]^}"' <<< "$1"; shift'
                            fi
                        else
                            # shellcheck disable=SC2016
                            codegenOutput "${codegenArgList[$k]^}"' <<< "$1"; shift; '
                        fi
                    else
                        codegenFormatType "${codegenArgList[$k - 1]}"
                        if [[ "$k" == $((argumentCount - 1)) ]]; then
                            if generateDebugCode; then
                                # shellcheck disable=SC2016
                                codegenOutput "${codegenArgList[$k]^}"'="$1"; shift; '
                            else
                                # shellcheck disable=SC2016
                                codegenOutput "${codegenArgList[$k]^}"'="$1"'
                            fi
                        else
                            # shellcheck disable=SC2016
                            codegenOutput "${codegenArgList[$k]^}"'="$1"; shift; '
                        fi
                    fi
                fi
            done
            ;;
        *)
            die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
        esac

        if generateDebugCode; then
            for (( k=0; k<argumentCount; k++ )); do
                if (( k % 2 )); then
                    case "$targetLang" in
                    js)
                        codegenOutput "await internalDebugCollect('"
                        codegenFormatType "${codegenArgList[$k - 1]}"
                        codegenOutput " ${codegenArgList[$k]^} = ' + "
                        codegenFormatType "${codegenArgList[$k - 1]}"
                        codegenOutput "${codegenArgList[$k]^} + '; '); "
                        ;;
                    bash)
                        codegenOutput 'internalDebugCollect "'
                        codegenFormatType "${codegenArgList[$k - 1]}"
                        # shellcheck disable=SC2016
                        codegenOutput " ${codegenArgList[$k]^}"' = ${'
                        codegenFormatType "${codegenArgList[$k - 1]}"
                        codegenOutput "${codegenArgList[$k]^}"'[@]}; "; '
                        ;;
                    *)
                        die "${FUNCNAME[0]} is not implemented in $targetLang."
                    ;;
                    esac
                fi
            done
            case "$targetLang" in
            js)
                codegenOutput "await internalDebugStackEnter('$codegenRoutineName:$filename');"
                ;;
            bash)
                codegenOutput "internalDebugStackEnter '$codegenRoutineName:$filename';"
                ;;
            *)
                die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
            esac
        fi
        if [[ "$argumentCount" != 0 ]] || [[ "${blockStack[-2]}" != "ident-r-v" ]]; then
            codegenOutput " "
        fi
        if generateRuntimeTypeCheckCode; then
            for (( k=0; k<argumentCount; k++ )); do
                if (( k % 2 )); then
                    [[ "$k" != 1 ]] && codegenOutput ' '
                    case "$targetLang" in
                    js)
                        codegenOutput "await assertIs"
                        codegenFormatType "${codegenArgList[$k - 1]}" "true"
                        codegenOutput "("
                        codegenFormatArgument "${codegenArgList[$k - 1]}" "${codegenArgList[$k]}"
                        codegenOutput ");"
                        ;;
                    bash)
                        codegenOutput "assertIs"
                        codegenFormatType "${codegenArgList[$k - 1]}" "true"
                        codegenOutput " "
                        codegenFormatArgument "${codegenArgList[$k - 1]}" "${codegenArgList[$k]}"
                        ;;
                    *)
                        die "${FUNCNAME[0]} is not implemented in $targetLang."
                    ;;
                    esac
                fi
            done
        fi
        if [[ "$argumentCount" != 0 ]] && [[ "${blockStack[-2]}" != "ident-r-v" ]]; then
            codegenOutput " "
        fi
        if [[ "${blockStack[-2]}" != "ident-r-v" ]]; then
            case "$targetLang" in
            js)
                codegenOutput "let "
                codegenFormatType "$codegenRoutineType"
                codegenOutput "Return;"
                ;;
            bash)
                true
                ;;
            *)
                die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
            esac
        fi
        codegenOutput $'\n\n'
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
    codegenRoutineType=""
    codegenRoutineName=""
    codegenArgList=()
}

# shellcheck disable=SC2120
codegenRoutineDefinitionPreEnd() {
    codegenDebug "Routine definition end" "${@}" >&2
    case "$targetLang" in
    js)
        if [[ "${blockStack[-2]}" == "ident-r-v" ]]; then
            codegenOutput $'\n'
            codegenIndent=$(( codegenIndent + 1 ))
            codegenPrintIndentationSpaces
            codegenIndent=$(( codegenIndent - 1 ))
        fi
        generateDebugCode && codegenOutput "await internalDebugStackExit();"
        if [[ "${blockStack[-2]}" == "ident-r-v" ]]; then
            codegenOutput $'\n'
        else
            codegenOutput " "
        fi
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

# shellcheck disable=SC2120
codegenRoutineDefinitionEnd() {
    codegenDebug "Routine definition end" "${@}" >&2
    case "$targetLang" in
    bash|c|cpp|cs|java|js|p6|php|pl|sh)
        # codegenOutput "}"$'\n'
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenIsTestCommand() {
    case "$1" in
    if|elif|until|while)
        true
        ;;
    *)
        false
        ;;
    esac
}

blockStackRemoveLast() {
    print_r "${blockStack[@]}" >&2
    if [[ "${blockStack[-1]}" == "" ]] && [[ "${blockStack[-2]}" == "plain-block" ]] && [[ "${blockStack[-4]}" == "test" ]]; then
        unset 'blockStack[-1]'
        unset 'blockStack[-1]'
    fi
    unset 'blockStack[-1]'
    [[ "${blockStack[-1]}" == "root" ]] && die "Internal error: Trying to remove root block!"
    unset 'blockStack[-1]'
}

codegenArrayAppend() {
    codegenArrayLiteral="$codegenArrayLiteral$1"
}

#set -x
for (( i=0; i<tokenCount; i++ )); do
    if ! (( (i+1) % 3 )); then
        codegenIndent="${tokens[$i - 2]##*:}"

        #declare -p tokens >&2
        #declare -p stateStack >&2
        echo >&2
        codegenStatus="State: ${stateStack[-1]}:$codegenIndent, token #$((i / 3 + 1)) (${tokens[$i - 2]}): ${tokens[$i - 1]} ($((i-1))): ${tokens[$i]} ($i)"
        codegenDebug

        if [[ "${tokens[$i - 1]}" == "filename" ]]; then
            filename="${tokens[$i]}"
        elif [[ "${tokens[$i - 1]}" == "comment" ]] && [[ "${stateStack[-1]}" != "arglist" ]] && [[ "${stateStack[-1]}" != literal-a* ]]; then
            echo "(Inserting a comment)" >&2
            codegenComment "$(asciiDecListToText "${tokens[$i]}")"
        elif [[ "${tokens[$i - 1]}" == "literal-ab-start" ]]; then
            codegenArrayAppend "$(codegenStartArray "b")"
            stateStack+=("literal-ab")
        elif [[ "${tokens[$i - 1]}" == "literal-an-start" ]]; then
            codegenArrayAppend "$(codegenStartArray "n")"
            stateStack+=("literal-an")
        elif [[ "${tokens[$i - 1]}" == "literal-as-start" ]]; then
            codegenArrayAppend "$(codegenStartArray "s")"
            stateStack+=("literal-as")
        else
            case "${stateStack[-1]}" in
            literal-ab)
                case "${tokens[$i - 1]}" in
                literal-ab-end)
                    codegenArrayAppend "$(codegenEndArray "b")"
                    unset 'stateStack[-1]'
                    i=$((i - 3))
                    ;;
                literal-b)
                    codegenArrayAppend "$(codegenLiteral "${tokens[$i - 1]}" "${tokens[$i]}")"
                    [[ "${tokens[$i + 2]}" =~ ^(literal-b|ident-b)$ ]] && codegenArrayAppend "$(codegenArrayEntryDelimiter)"
                    ;;
                ident-b)
                    codegenArrayAppend "$(codegenReference "${tokens[$i - 1]}" "${tokens[$i]}")"
                    [[ "${tokens[$i + 2]}" =~ ^(literal-b|ident-b)$ ]] && codegenArrayAppend "$(codegenArrayEntryDelimiter)"
                    ;;
                newline)
                    codegenArrayAppend "$(codegenArrayEntryDelimiter)"
                    codegenArrayAppend $'\n'"$(codegenPrintIndentationSpaces --force)"
                    codegenArrayAppend "$(codegenPrintIndentationSpaces)"
                    ;;
                *)
                    die "Unexpected token ${tokens[$i - 1]} in array of booleans."
                    ;;
                esac
                ;;
            literal-an)
                case "${tokens[$i - 1]}" in
                literal-an-end)
                    codegenArrayAppend "$(codegenEndArray "n")"
                    unset 'stateStack[-1]'
                    i=$((i - 3))
                    ;;
                literal-n)
                    codegenArrayAppend "$(codegenLiteral "${tokens[$i - 1]}" "${tokens[$i]}")"
                    [[ "${tokens[$i + 2]}" =~ ^(literal-n|ident-n)$ ]] && codegenArrayAppend "$(codegenArrayEntryDelimiter)"
                    ;;
                ident-n)
                    codegenArrayAppend "$(codegenReference "${tokens[$i - 1]}" "${tokens[$i]}")"
                    [[ "${tokens[$i + 2]}" =~ ^(literal-n|ident-n)$ ]] && codegenArrayAppend "$(codegenArrayEntryDelimiter)"
                    ;;
                newline)
                    codegenArrayAppend "$(codegenArrayEntryDelimiter)"
                    codegenArrayAppend $'\n'"$(codegenPrintIndentationSpaces --force)"
                    codegenArrayAppend "$(codegenPrintIndentationSpaces)"
                    ;;
                *)
                    die "Unexpected token ${tokens[$i - 1]} in array of numbers."
                    ;;
                esac
                ;;
            literal-as)
                case "${tokens[$i - 1]}" in
                literal-as-end)
                    codegenArrayAppend "$(codegenEndArray "s")"
                    unset 'stateStack[-1]'
                    i=$((i - 3))
                    ;;
                literal-s)
                    codegenArrayAppend "$(codegenLiteral "${tokens[$i - 1]}" "${tokens[$i]}")"
                    [[ "${tokens[$i + 2]}" =~ ^(literal-s|ident-s)$ ]] && codegenArrayAppend "$(codegenArrayEntryDelimiter)"
                    ;;
                ident-s)
                    codegenArrayAppend "$(codegenReference "${tokens[$i - 1]}" "${tokens[$i]}")"
                    [[ "${tokens[$i + 2]}" =~ ^(literal-s|ident-s)$ ]] && codegenArrayAppend "$(codegenArrayEntryDelimiter)"
                    ;;
                newline)
                    codegenArrayAppend "$(codegenArrayEntryDelimiter)"
                    codegenArrayAppend $'\n'"$(codegenPrintIndentationSpaces --force)"
                    codegenArrayAppend "$(codegenPrintIndentationSpaces)"
                    ;;
                *)
                    die "Unexpected token ${tokens[$i - 1]} in array of strings."
                    ;;
                esac
                ;;
            code)
                echo "Working on code" >&2
                case "${tokens[$i - 1]}" in
                start-document)
                    codegenStartDocument
                    ;;
                end-document)
                    unset 'stateStack[-1]'
                    i=$((i - 3))
                    ;;
                indent)
                    codegenIndent
                    stateStack+=("code")
                    blockStack+=("plain-block" "")
                    ;;
                dedent)
                    [[ "${blockStack[-2]}" == "ident-r-v" ]] && codegenRoutineDefinitionPreEnd # This gets generated before the return for non-void routines
                    codegenDedent
                    unset 'stateStack[-1]'
                    blockStackRemoveLast
                    if [[ "${blockStack[-2]}" == test-body-* ]]; then
                        blockStackRemoveLast
                    fi
                    ;;
                ident-r-*)
                    codegenRoutineName="$(asciiDecListToText "${tokens[$i]}")"
                    if ! [[ "${tokens[$i - 4]}" =~ ^(start-document|filename)$ ]]; then
                        codegenOutput $'\n'
                    fi
                    codegenRoutineType="${tokens[$i - 1]}"
                    stateStack+=("routine-definition")
                    blockStack+=("${tokens[$i - 1]}" "${tokens[$i]}")
                    ;;
                command)
                    codegenRoutineName="${tokens[$i]}"
                    case "${tokens[$i]}" in
                    if|elif|until|while)
                        stateStack+=("test")
                        blockStack+=("test-body-${tokens[$i]}" "" "test" "${tokens[$i]}")
                        codegenCommandInvocationStart
                        ;;
                    new|set)
                        stateStack+=("arglist")
                        blockStack+=("command" "${tokens[$i]}")
                        # We need to slurp up the first token of this arglist, representing the identifier, since it's needed by codegenCommandInvocationStart. Then, codegenCommandInvocationStart gets called.
                        stateStack+=("identifier-command-argument-accumulation")
                        ;;
                    return)
                        stateStack+=("oneshot-command")
                        ;;
                    *)
                        stateStack+=("arglist")
                        blockStack+=("command" "${tokens[$i]}")
                        codegenCommandInvocationStart
                        ;;
                    esac
                    ;;
                newline)
                    #[[ "${tokens[$i - 4]}" == "newline" ]] && codegenOutput $'\n'
                    ;;
                *)
                    die "A ${tokens[$i - 1]}, ${tokens[$i]}, isn't allowed here, in ${blockStack[-2]} ${blockStack[-1]}."
                    ;;
                esac
                ;;
            oneshot-command)
                case "${tokens[$i - 1]}" in
                literal-a*-end)
                    # Some type of data, array literal.
                    codegenArgList+=("${tokens[$i - 1]}" "$codegenArrayLiteral")
                    codegenArrayLiteral=""
                    ;;
                literal-*)
                    # Some type of data, literal.
                    codegenArgList+=("${tokens[$i - 1]}" "${tokens[$i]}")
                    ;;
                ident-*)
                    # Some type of data, reference.
                    codegenArgList+=("${tokens[$i - 1]}" "$(asciiDecListToText "${tokens[$i]}")")
                    ;;
                *)
                    # The arglist is ended, so do codegen for the command invocation, drop back and continue parsing.
                    codegenCommandInvocationStart
                    unset 'stateStack[-1]'
                    i=$((i - 3))
                    ;;
                esac
                ;;
            identifier-command-argument-accumulation)
                echo "Working on ${stateStack[-1]}" >&2
                case "${tokens[$i - 1]}" in
                ident-*)
                    codegenArgList+=("${tokens[$i - 1]}" "$(asciiDecListToText "${tokens[$i]}")")
                    unset 'stateStack[-1]'
                    tokenLookahead="${tokens[$i + 2]}" # should hold the next token type
                    codegenCommandInvocationStart
                    ;;
                *)
                    die "A ${blockStack[-2]} ${blockStack[-1]} wants an identifier here, not a ${tokens[$i - 1]}."
                    ;;
                esac
                ;;
            arglist|test)
                echo "Working on ${stateStack[-1]}" >&2
                case "${tokens[$i - 1]}" in
                literal-a*-end)
                    # Some type of data, array literal.
                    codegenArgList+=("${tokens[$i - 1]}" "$codegenArrayLiteral")
                    codegenArrayLiteral=""
                    ;;
                literal-*)
                    # Some type of data, literal.
                    [[ "${stateStack[-1]}" == "test" ]] && [[ "$testParameterFound" == "true" ]] && die "Multiple literals (in this case, the ${tokens[$i - 1]} \"${tokens[$i]}\") provided as parameters for a test-style construct."
                    [[ "${stateStack[-1]}" == "test" ]] && testParameterFound="true"
                    codegenArgList+=("${tokens[$i - 1]}" "${tokens[$i]}")
                    ;;
                command|ident-r-*)
                    if [[ "${tokens[$i]}" =~ ^(return|new|set)$ ]] || { [[ "${stateStack[-1]}" == "test" ]] && [[ "$testParameterFound" == "true" ]] ; }; then
                        # The arglist is ended, so drop back and continue parsing.
                        codegenCommandInvocationArglist
                        codegenCommandInvocationEnd
                        [[ "${stateStack[-1]}" == "test" ]] && testParameterFound="false"
                        unset 'stateStack[-1]'
                        i=$((i - 3))
                        if [[ "$codegenTestIndentDeferred" == "indent-deferred" ]]; then
                            codegenIndent
                            codegenTestIndentDeferred="false"
                            stateStack+=("code")
                            blockStack+=("plain-block" "")
                        fi
                    else
                        if [[ "${stateStack[-1]}" != "test" ]]; then
                            codegenCommandInvocationArglist
                            if ! codegenIsTestCommand "${tokens[$i - 3]}"; then
                                [[ "$codegenLastKnownArglistCount" != 0 ]] && codegenCommandInvocationArgSeparator
                            fi
                        fi
                        codegenRoutineName="${tokens[$i]}"
                        [[ "${tokens[$i - 1]}" == ident-r-* ]] && codegenRoutineName="$(asciiDecListToText "${tokens[$i]}")"
                        codegenCommandInvocationStart
                        if [[ "${stateStack[-1]}" == "test" ]]; then
                            testParameterFound="true"
                        fi
                        stateStack+=("arglist")
                        blockStack+=("arglist-command" "${tokens[$i]}")
                    fi
                    ;;
                ident-*)
                    # Some type of data, reference.
                    [[ "${stateStack[-1]}" == "test" ]] && [[ "$testParameterFound" == "true" ]] && die "Multiple identifiers (in this case, the ${tokens[$i - 1]} \"${tokens[$i]}\") provided as parameters for a test-style construct."
                    [[ "${stateStack[-1]}" == "test" ]] && testParameterFound="true"
                    codegenArgList+=("${tokens[$i - 1]}" "$(asciiDecListToText "${tokens[$i]}")")
                    ;;
                indent)
                    if [[ "$testParameterFound" == "true" ]]; then
                        [[ "${stateStack[-1]}" == "test" ]] && testParameterFound="false"
                        # The arglist is ended, so do codegen for the command invocation, drop back and continue parsing.
                        codegenCommandInvocationArglist
                        codegenCommandInvocationEnd
                        unset 'stateStack[-1]'
                        if [[ "$codegenTestIndentDeferred" == "indent-deferred" ]]; then
                            codegenIndent
                            codegenTestIndentDeferred="false"
                            stateStack+=("code")
                            blockStack+=("plain-block" "")
                        fi
                        i=$((i - 3))
                    fi
                    ;;
                newline)
                    if [[ "${stateStack[-1]}" != "test" ]]; then
                        # The arglist is ended, so do codegen for the command invocation, drop back and continue parsing.
                        # (This gets called multiple times for a single test, when there are multiple arglists to close for it.)
                        if [[ "${blockStack[-1]}" != "else" ]]; then
                            codegenCommandInvocationArglist
                        fi
                        codegenCommandInvocationEnd
                        unset 'stateStack[-1]'
                        i=$((i - 3))
                    fi
                    # If the test continues onto a new line, make a note that the indentation count will be offset accordingly until the end of the test is found.
                    if [[ "${stateStack[-1]}" == "test" ]] && [[ "$testParameterFound" != "true" ]]; then
                        codegenOutput $'\n'
                        codegenTestIndentDeferred="indent-deferred"
                    fi
                    ;;
                inline-arglist-end)
                    codegenCommandInvocationArglist
                    codegenCommandInvocationEnd
                    codegenCommandInvocationArgSeparator
                    unset 'stateStack[-1]' # remove latest "arglist" state
                    ;;
                dedent|end-document|*)
                    # The arglist or test parameter is ended, so do codegen for the command invocation, drop back and continue parsing.
                    # * matches e.g. routine definitions
                    codegenCommandInvocationArglist
                    codegenCommandInvocationEnd
                    #[[ "${tokens[$i - 1]}" == "dedent" ]] || codegenIndent
                    unset 'stateStack[-1]'
                    i=$((i - 3))
                    [[ "${stateStack[-1]}" == "test" ]] && testParameterFound="false"
                    stateStack+=("code")
                    ;;
                *)
                    die "What's this token ${tokens[$i - 1]} ${tokens[$i]} doing here? does it need special handling?"
                    ;;
                esac
                ;;
            routine-definition)
                echo "Working on routine definition" >&2
                # Format: token, [ident...], code body
                # So now we look for as many types as there are. When no more types, it enters the code body of the routine. When there's a dedent, it leaves the code body of the routine.
                case "${tokens[$i - 1]}" in
                ident-*)
                    # Some type of data, reference.
                    codegenArgList+=("${tokens[$i - 1]}" "$(asciiDecListToText "${tokens[$i]}")")
                    ;;
                indent|newline)
                    # The routine definition parameter list is ended, so do codegen for the routine declaration (but not the body of it), and continue parsing.
                    codegenRoutineDefinitionStart
                    stateStack[-1]="routine-definition-end"
                    stateStack+=("code")
                    # Avoid putting in an extra code level
                    [[ "${tokens[$i - 1]}" == "newline" ]] && [[ "${tokens[$i + 2]}" == "indent" ]] && i=$((i + 3))
                    ;;
                *)
                    die "Routine definition unexpected token type"
                esac
                ;;
            routine-definition-end)
                echo "Working on routine definition end" >&2
                # Note that this is called AFTER the dedent closing brace is produced. Use codegenRoutineDefinitionPreEnd instead for things that go before the end of the routine def.
                [[ "${tokens[$i - 1]}" == "dedent" ]] && codegenDedent
                unset 'stateStack[-1]'
                codegenRoutineDefinitionEnd
                # And we'll reprocess this token now that we're done with this routine-definition.
                i=$((i - 3))
                # Don't call blockStackRemoveLast here: routine-definition-end state is entered by encountering a dedent while in code mode of the body of the routine, which will pop from the stateStack (thereby uncovering the routine-definition-end state) and take care of calling blockStackRemoveLast.
                ;;
            root)
                case "${tokens[$i - 1]}" in
                end-document)
                    codegenEndDocument
                    ;;
                *)
                    ;;
                esac
                true
                ;;
            *)
                die "Unimplemented code generation state ${stateStack[-1]}"
                ;;
            esac
        fi
    fi
done

{ [[ "${#blockStack[@]}" == "2" ]] && [[ "${blockStack[0]}" == "root" ]] && [[ "${blockStack[1]}" == "" ]]; } || die "Internal error: not all blocks were consumed, or too many blocks were consumed! This is a bug in the StageL transpiler. Remaining block stack: ${blockStack[*]}"

print_r "${stateStack[@]}" >&2
print_r "${blockStack[@]}" >&2
